{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"As part of this short tutorial we will explore few security concepts that are required with every microservice deployment and how Gloo Edge can help you to configure them easily and securely. At the end of this short tutorial you would have learnt, Setup minikube cluster Deploy Gloo Edge Enterprise minikube cluster Secure your Cloud Native Applications with Gloo Edge by, Doing RateLimiting Doing WAF Doing CORS Doing oAuth Doing Traffic Encrypton","title":"Overview"},{"location":"auth/","text":"At the end of this chapter you would have known how to: Deploy dexidp Configure authentication to Fruits API Pre-requisties \u00b6 We will be integrating GitHub via dexidp. For us to integrate dex with GithHub oAuth you need to have oAuth app registered and have the follwing credentials handy, GitHub oAuth ClientId GitHub oAuth CientSecret GitHub Organisation to use Ensure Enviroment \u00b6 We will use the following variables as part of this module, export GH_OAUTH_CLIENT_ID = <your github oauth client id> export GH_OAUTH_CLIENT_SECRET = <your github oauth client secret> export GH_OAUTH_ORG = <the github org to use> Prepare Dex Deployment \u00b6 Create Namespace \u00b6 kubectl apply -f $TUTORIAL_HOME /cluster/dex/namespace.yaml Create Github Secret Env file \u00b6 TODO Check Copy the template to env file, cp $TUTORIAL_HOME /cluster/dex/github.env.secret.template $TUTORIAL_HOME /cluster/dex/github.env.secret Update the $TUTORIAL_HOME/cluster/dex/github.env.secret values to map to your environment. Copy Trusted CA certificates \u00b6 envsubst < $TUTORIAL_HOME /cluster/gloo/trusted-ca.yaml | kubectl apply -n dex -f - Dex SSL Certificates \u00b6 To create the Dex SSL certificate, we need to know the dex service LoadBalancer IP. To get the LB IP let us create the dex service, kubectl apply -n dex -f $TUTORIAL_HOME /cluster/dex/service.yaml Get the dex LoadBalancer IP, export DEX_SERVER_IP = $( kubectl get svc -n dex dex -ojson | jq -r '.status.loadBalancer.ingress[0].ip' ) Create Dex CSR \u00b6 Let us create the CSR and keys, step certificate create gloo-demos-dex --csr \\ --san \" ${ DEX_SERVER_IP } .nip.io\" \\ --san \"*- ${ DEX_SERVER_IP } .nip.io\" \\ --san \"*. ${ DEX_SERVER_IP } .nip.io\" \\ --san \" ${ DEX_SERVER_IP } \" \\ --password-file $TUTORIAL_HOME /certs/password-file \\ $TUTORIAL_HOME /certs/gloo-demos-dex.csr $TUTORIAL_HOME /certs/gloo-demos-dex-key If all goes well you should have the gloo-demos-dex.csr and gloo-demos-dex-key files in the $TUTORIAL_HOME/certs folder. Create Certificate Request \u00b6 Having created the CSR we are good to create the cert-manager\u2019s CertificateRequest , As first step let us base64 encode the gloo-demos-dex CSR , export GLOO_DEMOS_DEX_CSR = $( cat $TUTORIAL_HOME /certs/gloo-demos-dex.csr | step base64 | tr -d '\\n' ) Create the CertificateRequest , envsubst< $TUTORIAL_HOME /cluster/dex/certificate-request.yaml | kubectl create -f - Check the status of the CertificateRequest , kubectl get certificaterequests.cert-manager.io -n step-certificates-system ${ DEX_SERVER_IP } .nip.io -o json | jq '.status.conditions[]' If all went well you should see an output like, { \"lastTransitionTime\" : \"2021-08-27T16:15:14Z\" , \"message\" : \"Certificate request has been approved by cert-manager.io\" , \"reason\" : \"cert-manager.io\" , \"status\" : \"True\" , \"type\" : \"Approved\" } { \"lastTransitionTime\" : \"2021-08-27T16:15:14Z\" , \"message\" : \"Certificate issued\" , \"reason\" : \"Issued\" , \"status\" : \"True\" , \"type\" : \"Ready\" } Wait for the certificate to be updated in the request, you can check the same via, CA Certificate can be retrieved by, kubectl get certificaterequests.cert-manager.io -n step-certificates-system ${ DEX_SERVER_IP } .nip.io -o json | jq -r '.status.ca' | step base64 -d > $TUTORIAL_HOME /certs/gloo-demos-dex-ca.crt TLS Certificate can be retrieved by, kubectl get certificaterequests.cert-manager.io -n step-certificates-system ${ DEX_SERVER_IP } .nip.io -o json | jq -r '.status.certificate' | step base64 -d > $TUTORIAL_HOME /certs/gloo-demos-dex.crt Verify Certificates \u00b6 $TUTORIAL_HOME /bin/verifyCerts.sh $TUTORIAL_HOME /certs/gloo-demos-dex.crt $DEX_SERVER_IP .nip.io With Verification succeeded! , we are now all set to encrypt our gateway traffic. Create SSL Secret \u00b6 To be able to encrypt the traffic via Gloo Gateway, we need to configure the TLS certicates. The TLS certficate is configured using Kubernetes Secret. Decrypt the private key that we used to create the Certificate Signing Request, step certificate key $TUTORIAL_HOME /certs/gloo-demos-dex-key --out = $TUTORIAL_HOME /certs/gloo-demos-dex.key Note The command out put says its public key, but its actually decrypted private key kubectl create secret generic dex-tls -n dex \\ --from-file = tls.crt = $TUTORIAL_HOME /certs/gloo-demos-dex.crt \\ --from-file = tls.key = $TUTORIAL_HOME /certs/gloo-demos-dex.key \\ --from-file = ca.crt = $TUTORIAL_HOME /certs/gloo-demos-dex-ca.crt Deploy Dex \u00b6 kustomize build $TUTORIAL_HOME /cluster/dex \\ | envsubst | kubectl apply -f - Wait for the dex deployment to be up and running kubectl rollout status -n dex deploy/dex --timeout = 60s Create Gloo oAuth Secret \u00b6 We have configured the fruits-app static client to identify itself with dex using a secret, the following snippet from dex config.yaml shows the base64 encoded secret that was configured, staticClients : - id : fruits-app redirectURIs : - 'https://$GLOO_GATEWAY_PROXY_IP/callback' name : 'Fruits App' # value is fruits-app-secret secret : \"nJ1aXRzLWFwcC1zZWNyZXQ=\" The value of the client-secret is same as the secret value in the dex config.yaml . Let us create the Gloo oAuth secret to be used, glooctl create secret oauth \\ --client-secret 'fruits-app-secret' fruits-app-oauth Gloo oAuth Config \u00b6 envsubst < $TUTORIAL_HOME /apps/microservice/fruits-api/gloo/auth-config.yaml \\ | kubectl apply -f - Update Virtual Service \u00b6 Now let us update the virtual service to use the oAuth config, envsubst < $TUTORIAL_HOME /apps/microservice/fruits-api/gloo/virtual-service-oauth.yaml \\ | kubectl apply -f - Accessing Application \u00b6 When you try to open the URL $GLOO_PROXY_HTTPS_URL/api/fruits in the web browser you will be thrown an login screen as shown: Enter the email address as admin@example.com with passsword as password . With successful login we will be asked permissions for Grants , With us approving the grants we will be shown the list of fruits,","title":"Authentication"},{"location":"auth/#pre-requisties","text":"We will be integrating GitHub via dexidp. For us to integrate dex with GithHub oAuth you need to have oAuth app registered and have the follwing credentials handy, GitHub oAuth ClientId GitHub oAuth CientSecret GitHub Organisation to use","title":"Pre-requisties"},{"location":"auth/#ensure-enviroment","text":"We will use the following variables as part of this module, export GH_OAUTH_CLIENT_ID = <your github oauth client id> export GH_OAUTH_CLIENT_SECRET = <your github oauth client secret> export GH_OAUTH_ORG = <the github org to use>","title":"Ensure Enviroment"},{"location":"auth/#prepare-dex-deployment","text":"","title":"Prepare Dex Deployment"},{"location":"auth/#create-namespace","text":"kubectl apply -f $TUTORIAL_HOME /cluster/dex/namespace.yaml","title":"Create Namespace"},{"location":"auth/#create-github-secret-env-file","text":"TODO Check Copy the template to env file, cp $TUTORIAL_HOME /cluster/dex/github.env.secret.template $TUTORIAL_HOME /cluster/dex/github.env.secret Update the $TUTORIAL_HOME/cluster/dex/github.env.secret values to map to your environment.","title":"Create Github Secret Env file"},{"location":"auth/#copy-trusted-ca-certificates","text":"envsubst < $TUTORIAL_HOME /cluster/gloo/trusted-ca.yaml | kubectl apply -n dex -f -","title":"Copy Trusted CA certificates"},{"location":"auth/#dex-ssl-certificates","text":"To create the Dex SSL certificate, we need to know the dex service LoadBalancer IP. To get the LB IP let us create the dex service, kubectl apply -n dex -f $TUTORIAL_HOME /cluster/dex/service.yaml Get the dex LoadBalancer IP, export DEX_SERVER_IP = $( kubectl get svc -n dex dex -ojson | jq -r '.status.loadBalancer.ingress[0].ip' )","title":"Dex SSL Certificates"},{"location":"auth/#create-dex-csr","text":"Let us create the CSR and keys, step certificate create gloo-demos-dex --csr \\ --san \" ${ DEX_SERVER_IP } .nip.io\" \\ --san \"*- ${ DEX_SERVER_IP } .nip.io\" \\ --san \"*. ${ DEX_SERVER_IP } .nip.io\" \\ --san \" ${ DEX_SERVER_IP } \" \\ --password-file $TUTORIAL_HOME /certs/password-file \\ $TUTORIAL_HOME /certs/gloo-demos-dex.csr $TUTORIAL_HOME /certs/gloo-demos-dex-key If all goes well you should have the gloo-demos-dex.csr and gloo-demos-dex-key files in the $TUTORIAL_HOME/certs folder.","title":"Create Dex CSR"},{"location":"auth/#create-certificate-request","text":"Having created the CSR we are good to create the cert-manager\u2019s CertificateRequest , As first step let us base64 encode the gloo-demos-dex CSR , export GLOO_DEMOS_DEX_CSR = $( cat $TUTORIAL_HOME /certs/gloo-demos-dex.csr | step base64 | tr -d '\\n' ) Create the CertificateRequest , envsubst< $TUTORIAL_HOME /cluster/dex/certificate-request.yaml | kubectl create -f - Check the status of the CertificateRequest , kubectl get certificaterequests.cert-manager.io -n step-certificates-system ${ DEX_SERVER_IP } .nip.io -o json | jq '.status.conditions[]' If all went well you should see an output like, { \"lastTransitionTime\" : \"2021-08-27T16:15:14Z\" , \"message\" : \"Certificate request has been approved by cert-manager.io\" , \"reason\" : \"cert-manager.io\" , \"status\" : \"True\" , \"type\" : \"Approved\" } { \"lastTransitionTime\" : \"2021-08-27T16:15:14Z\" , \"message\" : \"Certificate issued\" , \"reason\" : \"Issued\" , \"status\" : \"True\" , \"type\" : \"Ready\" } Wait for the certificate to be updated in the request, you can check the same via, CA Certificate can be retrieved by, kubectl get certificaterequests.cert-manager.io -n step-certificates-system ${ DEX_SERVER_IP } .nip.io -o json | jq -r '.status.ca' | step base64 -d > $TUTORIAL_HOME /certs/gloo-demos-dex-ca.crt TLS Certificate can be retrieved by, kubectl get certificaterequests.cert-manager.io -n step-certificates-system ${ DEX_SERVER_IP } .nip.io -o json | jq -r '.status.certificate' | step base64 -d > $TUTORIAL_HOME /certs/gloo-demos-dex.crt","title":"Create Certificate Request"},{"location":"auth/#verify-certificates","text":"$TUTORIAL_HOME /bin/verifyCerts.sh $TUTORIAL_HOME /certs/gloo-demos-dex.crt $DEX_SERVER_IP .nip.io With Verification succeeded! , we are now all set to encrypt our gateway traffic.","title":"Verify Certificates"},{"location":"auth/#create-ssl-secret","text":"To be able to encrypt the traffic via Gloo Gateway, we need to configure the TLS certicates. The TLS certficate is configured using Kubernetes Secret. Decrypt the private key that we used to create the Certificate Signing Request, step certificate key $TUTORIAL_HOME /certs/gloo-demos-dex-key --out = $TUTORIAL_HOME /certs/gloo-demos-dex.key Note The command out put says its public key, but its actually decrypted private key kubectl create secret generic dex-tls -n dex \\ --from-file = tls.crt = $TUTORIAL_HOME /certs/gloo-demos-dex.crt \\ --from-file = tls.key = $TUTORIAL_HOME /certs/gloo-demos-dex.key \\ --from-file = ca.crt = $TUTORIAL_HOME /certs/gloo-demos-dex-ca.crt","title":"Create SSL Secret"},{"location":"auth/#deploy-dex","text":"kustomize build $TUTORIAL_HOME /cluster/dex \\ | envsubst | kubectl apply -f - Wait for the dex deployment to be up and running kubectl rollout status -n dex deploy/dex --timeout = 60s","title":"Deploy Dex"},{"location":"auth/#create-gloo-oauth-secret","text":"We have configured the fruits-app static client to identify itself with dex using a secret, the following snippet from dex config.yaml shows the base64 encoded secret that was configured, staticClients : - id : fruits-app redirectURIs : - 'https://$GLOO_GATEWAY_PROXY_IP/callback' name : 'Fruits App' # value is fruits-app-secret secret : \"nJ1aXRzLWFwcC1zZWNyZXQ=\" The value of the client-secret is same as the secret value in the dex config.yaml . Let us create the Gloo oAuth secret to be used, glooctl create secret oauth \\ --client-secret 'fruits-app-secret' fruits-app-oauth","title":"Create Gloo oAuth Secret"},{"location":"auth/#gloo-oauth-config","text":"envsubst < $TUTORIAL_HOME /apps/microservice/fruits-api/gloo/auth-config.yaml \\ | kubectl apply -f -","title":"Gloo oAuth Config"},{"location":"auth/#update-virtual-service","text":"Now let us update the virtual service to use the oAuth config, envsubst < $TUTORIAL_HOME /apps/microservice/fruits-api/gloo/virtual-service-oauth.yaml \\ | kubectl apply -f -","title":"Update Virtual Service"},{"location":"auth/#accessing-application","text":"When you try to open the URL $GLOO_PROXY_HTTPS_URL/api/fruits in the web browser you will be thrown an login screen as shown: Enter the email address as admin@example.com with passsword as password . With successful login we will be asked permissions for Grants , With us approving the grants we will be shown the list of fruits,","title":"Accessing Application"},{"location":"cors/","text":"At the end of this chapter you would have known how to: Configure CORS Gloo Edge also supports configuring the CORS policies without the need to redeploy the backend API application. As part of this section we will extend our demo Fruits API with simple SPA . Build the UI Application \u00b6 Since the SPA are accessed from browser we need to rebuild the UI with th GLOO_PROXY_URL that the application need to use, docker build --build-arg = \"GLOO_PROXY_URL= $GLOO_PROXY_URL \" \\ -t example/fruits-ui \\ -f $TUTORIAL_HOME /Dockerfile-UI $TUTORIAL_HOME Once the contianer is built let us run it, docker run --rm -p 8085 :8080 example/fruits-ui When you open the localhost:8085 in the browser you will see application page like When you open the browser\u2019 developer tools console, you should notice the CORS errors like: Update Virtual Service \u00b6 To fix this we need to update the Virutal Service with CORS options, apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : fruits-api namespace : gloo-system spec : displayName : FruitsAPI virtualHost : options : # -------- CORS Config ----------- cors : # (1) allowOriginRegex : - '^http(s)?:\\/\\/localhost:[0-9]{4,5}$' # (2) allowHeaders : # (3) - origin - content-type allowMethods : # (4) - DELETE maxAge : 1d # -------- Web Application Firewall - Check User-Agent ----------- waf : customInterventionMessage : \"Firefox not supported\" ruleSets : - ruleStr : | SecRuleEngine On SecRule REQUEST_HEADERS:User-Agent \".*Firefox.*\" \"deny,status:403,id:107,phase:1,msg:'unsupported user agent'\" domains : - \"*\" routes : # --------------------- Application Routes ----------------- - matchers : - prefix : /api/ routeAction : single : upstream : name : fruits-app-fruits-api-8080 namespace : gloo-system options : prefixRewrite : /v1/api/ # ---------------- Rate limit config ---------------------- rateLimitConfigs : refs : - name : global-limit namespace : gloo-system Enable CORS options The Origin Regular Expression, this will allow all localhost The CORS headers that are allowed The methods that the orgins can excute Now let us update the virtual service, kubectl apply -n gloo-system -f $TUTORIAL_HOME /apps/microservice/fruits-api/gloo/virtual-service-cors.yaml Now try refreshing the browser url localhost:8085 and you will see a list of fruits as shown without any CORS errors.","title":"CORS"},{"location":"cors/#build-the-ui-application","text":"Since the SPA are accessed from browser we need to rebuild the UI with th GLOO_PROXY_URL that the application need to use, docker build --build-arg = \"GLOO_PROXY_URL= $GLOO_PROXY_URL \" \\ -t example/fruits-ui \\ -f $TUTORIAL_HOME /Dockerfile-UI $TUTORIAL_HOME Once the contianer is built let us run it, docker run --rm -p 8085 :8080 example/fruits-ui When you open the localhost:8085 in the browser you will see application page like When you open the browser\u2019 developer tools console, you should notice the CORS errors like:","title":"Build the UI Application"},{"location":"cors/#update-virtual-service","text":"To fix this we need to update the Virutal Service with CORS options, apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : fruits-api namespace : gloo-system spec : displayName : FruitsAPI virtualHost : options : # -------- CORS Config ----------- cors : # (1) allowOriginRegex : - '^http(s)?:\\/\\/localhost:[0-9]{4,5}$' # (2) allowHeaders : # (3) - origin - content-type allowMethods : # (4) - DELETE maxAge : 1d # -------- Web Application Firewall - Check User-Agent ----------- waf : customInterventionMessage : \"Firefox not supported\" ruleSets : - ruleStr : | SecRuleEngine On SecRule REQUEST_HEADERS:User-Agent \".*Firefox.*\" \"deny,status:403,id:107,phase:1,msg:'unsupported user agent'\" domains : - \"*\" routes : # --------------------- Application Routes ----------------- - matchers : - prefix : /api/ routeAction : single : upstream : name : fruits-app-fruits-api-8080 namespace : gloo-system options : prefixRewrite : /v1/api/ # ---------------- Rate limit config ---------------------- rateLimitConfigs : refs : - name : global-limit namespace : gloo-system Enable CORS options The Origin Regular Expression, this will allow all localhost The CORS headers that are allowed The methods that the orgins can excute Now let us update the virtual service, kubectl apply -n gloo-system -f $TUTORIAL_HOME /apps/microservice/fruits-api/gloo/virtual-service-cors.yaml Now try refreshing the browser url localhost:8085 and you will see a list of fruits as shown without any CORS errors.","title":"Update Virtual Service"},{"location":"deploy-app/","text":"Deploy App \u00b6 The demo application that will be deployed is a simple Fruits microservice. The source code the Fruits API is available here . At the end of this chapter you would have deployed a cloud native application that will be used in learning the Gloo Concepts. Deploy Database \u00b6 kubectl apply -k $TUTORIAL_HOME /apps/microservice/fruits-api/db Wait for the DB to be up kubectl rollout status -n db deploy/postgresql --timeout = 60s Waiting for deployment \u201cpostgresql\u201d rollout to finish: 0 of 1 updated replicas are available\u2026 deployment \u201cpostgresql\u201d successfully rolled out Deploy REST API \u00b6 kubectl apply -k $TUTORIAL_HOME /apps/microservice/fruits-api/app Wait for the REST API to be up kubectl rollout status -n fruits-app deploy/fruits-api --timeout = 60s Waiting for deployment \u201cfruits-api\u201d rollout to finish: 0 of 1 updated replicas are available\u2026 deployment \u201cfruits-api\u201d successfully rolled out","title":"Deploy Microservice"},{"location":"deploy-app/#deploy-app","text":"The demo application that will be deployed is a simple Fruits microservice. The source code the Fruits API is available here . At the end of this chapter you would have deployed a cloud native application that will be used in learning the Gloo Concepts.","title":"Deploy App"},{"location":"deploy-app/#deploy-database","text":"kubectl apply -k $TUTORIAL_HOME /apps/microservice/fruits-api/db Wait for the DB to be up kubectl rollout status -n db deploy/postgresql --timeout = 60s Waiting for deployment \u201cpostgresql\u201d rollout to finish: 0 of 1 updated replicas are available\u2026 deployment \u201cpostgresql\u201d successfully rolled out","title":"Deploy Database"},{"location":"deploy-app/#deploy-rest-api","text":"kubectl apply -k $TUTORIAL_HOME /apps/microservice/fruits-api/app Wait for the REST API to be up kubectl rollout status -n fruits-app deploy/fruits-api --timeout = 60s Waiting for deployment \u201cfruits-api\u201d rollout to finish: 0 of 1 updated replicas are available\u2026 deployment \u201cfruits-api\u201d successfully rolled out","title":"Deploy REST API"},{"location":"encrypt/","text":"At the end of this chapter you would have known how to: Create Certificates for Fruits App Configure Gloo Virtual Service with SSL /TLS Ensure Environment \u00b6 We will be using few enviornment variables that we crated earlier, validate if the output of the following print statements matches your environment, echo \"\\nGloo Gateway Proxy IP: ${ GLOO_GATEWAY_PROXY_IP } \\n\" echo \"\\nMinikube IP: ${ MINIKUBE_IP } \\n\" echo \"\\nStepCA Password: ${ STEP_CA_PASSWORD } \\n\" Certifcate Request \u00b6 As part of earlier chapter , we have step our CA and StepIssuer that helps us to create cert-manager CertificateRequests to generate the certificates. As first step of that we need to create a CSR , we can use step cli to create the CSR . Create a password file to that will be used to encrypt the keys, for the sake of this demo let use use our $STEP_CA_PASSWORD as our password to encrypt the keys, echo \" $STEP_CA_PASSWORD \" > $TUTORIAL_HOME /certs/password-file Let us create the CSR and keys, step certificate create gloo-demos --csr \\ --san \" ${ GLOO_GATEWAY_PROXY_IP } .nip.io\" \\ --san \" ${ MINIKUBE_IP } .nip.io\" \\ --san \"*- ${ GLOO_GATEWAY_PROXY_IP } .nip.io\" \\ --san \"*. ${ GLOO_GATEWAY_PROXY_IP } .nip.io\" \\ --san \"*- ${ MINIKUBE_IP } .nip.io\" \\ --san \" ${ GLOO_GATEWAY_PROXY_IP } \" \\ --san \" ${ MINIKUBE_IP } \" \\ --password-file $TUTORIAL_HOME /certs/password-file \\ $TUTORIAL_HOME /certs/gloo-demos.csr $TUTORIAL_HOME /certs/gloo-demos-key If all goes well you should have the gloo-demos.csr and gloo-demos-key files in the $TUTORIAL_HOME/certs folder. Create Certificate Request \u00b6 Having created the CSR we are good to create the cert-manager\u2019s CertificateRequest , As first step let us base64 encode the gloo-demos CSR , export GLOO_DEMOS_CSR = $( cat $TUTORIAL_HOME /certs/gloo-demos.csr | step base64 | tr -d '\\n' ) Create the CertificateRequest , envsubst< $TUTORIAL_HOME /cluster/ssl/certificate-request.yaml | kubectl create -f - Check the status of the CertificateRequest , kubectl get certificaterequests.cert-manager.io -n step-certificates-system ${ GLOO_GATEWAY_PROXY_IP } .nip.io -o json | jq '.status.conditions[]' If all went well you should see an output like, { \"lastTransitionTime\" : \"2021-08-26T07:34:30Z\" , \"message\" : \"Certificate request has been approved by cert-manager.io\" , \"reason\" : \"cert-manager.io\" , \"status\" : \"True\" , \"type\" : \"Approved\" } { \"lastTransitionTime\" : \"2021-08-26T07:34:30Z\" , \"message\" : \"Certificate issued\" , \"reason\" : \"Issued\" , \"status\" : \"True\" , \"type\" : \"Ready\" } Wait for the certificate to be updated in the request, you can check the same via, CA Certificate can be retrieved by, kubectl get certificaterequests.cert-manager.io -n step-certificates-system ${ GLOO_GATEWAY_PROXY_IP } .nip.io -o json | jq -r '.status.ca' | step base64 -d > $TUTORIAL_HOME /certs/gloo-demos-ca.crt TLS Certificate can be retrieved by, kubectl get certificaterequests.cert-manager.io -n step-certificates-system ${ GLOO_GATEWAY_PROXY_IP } .nip.io -o json | jq -r '.status.certificate' | step base64 -d > $TUTORIAL_HOME /certs/gloo-demos.crt Verify Certificates \u00b6 $TUTORIAL_HOME /bin/verifyCerts.sh $TUTORIAL_HOME /certs/gloo-demos.crt $GLOO_GATEWAY_PROXY_IP .nip.io With Verification succeeded! , we are now all set to encrypt our gateway traffic. Create SSL Secret \u00b6 To be able to encrypt the traffic via Gloo Gateway, we need to configure the TLS certicates. The TLS certficate is configured using Kubernetes Secret. Decrypt the private key that we used to create the Certificate Signing Request, step certificate key $TUTORIAL_HOME /certs/gloo-demos-key --out = $TUTORIAL_HOME /certs/gloo-demos.key Note The command out put says its public key, but its actually decrypted private key Let us create a Kubernetes secret that we will use later to configure the TLS for Gloo Virtual Service, glooctl create secret tls $GLOO_GATEWAY_PROXY_IP .nip.io-tls \\ --certchain $TUTORIAL_HOME /certs/gloo-demos.crt \\ --privatekey = $TUTORIAL_HOME /certs/gloo-demos.key \\ --rootca = $TUTORIAL_HOME /certs/root_ca.crt +---------------------------+------+ | SECRET | TYPE | +---------------------------+------+ | 192.168.64.200.nip.io-tls | TLS | +---------------------------+------+ You can check the contents of the secret using, kubectl get secrets -n gloo-system $GLOO_GATEWAY_PROXY_IP .nip.io-tls -o json \\ | jq -r '.data.tls' \\ | step base64 -d Gloo Proxy URLS \u00b6 Get the Gloo proxy URLs, export GLOO_HTTPS_PROXY_URL = \"https:// ${ GLOO_GATEWAY_PROXY_IP } .nip.io\" export GLOO_HTTP_PROXY_URL = \"http:// ${ GLOO_GATEWAY_PROXY_IP } .nip.io\" Encrypt Fruits API Route \u00b6 As we have all the infrastructure ready to encrypt the traffic let us now configure the fruits-api Virtual Service to encrypt the traffic with our certificates. Mutual TLS ( mTLS ) \u00b6 Let us update the fruits-api Virtual Service to enable SSL via the sslConfig block as shown, apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : fruits-api namespace : gloo-system spec : displayName : FruitsAPI sslConfig : secretRef : name : \"${GLOO_GATEWAY_PROXY_IP}.nip.io-tls\" namespace : gloo-system virtualHost : domains : - \"${GLOO_GATEWAY_PROXY_IP}.nip.io\" routes : # Application Routes # ------------ - matchers : - prefix : /api/ routeAction : single : upstream : name : fruits-app-fruits-api-8080 namespace : gloo-system options : prefixRewrite : /v1/api/ Apply the changes by running, envsubst < $TUTORIAL_HOME /apps/microservice/fruits-api/gloo/virtual-service-mtls.yaml \\ | kubectl apply -f - Let us check the service, http --verify = $TUTORIAL_HOME /certs/gloo-demos-ca.crt \" $GLOO_HTTPS_PROXY_URL /api/fruits/\" Even though we specifed the CA the call fails with the following error, http: error: SSLError: HTTPSConnectionPool(host='192.168.64.200.nip.io', port=443): Max retries exceeded with url: /api/fruits/ (Caused by SSLError(SSLError(1, '[SSL: TLSV13_ALERT_CERTIFICATE_REQUIRED] tlsv13 alert certificate required (_ssl.c:2633)'))) while doing a GET request to URL: https://192.168.64.200.nip.io/api/fruits/ The error means we need supply the client certificate and key as part of the request.By default Envoy Proxy does enable mTLS when the Kubernetes secret has ca.crt . Since we not called it with client certificates the call fails with the error, Now let us add the client certificates and do the call again, http \\ --verify = \" $TUTORIAL_HOME /certs/gloo-demos-ca.crt\" \\ --cert = \" $TUTORIAL_HOME /certs/gloo-demos.crt\" \\ --cert-key = \" $TUTORIAL_HOME /certs/gloo-demos.key\" \\ \" $GLOO_HTTPS_PROXY_URL /api/fruits/\" The call is now sucessful returning the list of fruits, [ { \"id\" : 8 , \"name\" : \"Apple\" , \"season\" : \"Fall\" , \"emoji\" : \"U+1F34E\" }, { \"id\" : 6 , \"name\" : \"Banana\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1F34C\" }, { \"id\" : 5 , \"name\" : \"Blueberry\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1FAD0\" }, { \"id\" : 4 , \"name\" : \"Lemon\" , \"season\" : \"Winter\" , \"emoji\" : \"U+1F34B\" }, { \"id\" : 1 , \"name\" : \"Mango\" , \"season\" : \"Spring\" , \"emoji\" : \"U+1F96D\" }, { \"id\" : 3 , \"name\" : \"Orange\" , \"season\" : \"Winter\" , \"emoji\" : \"U+1F34A\" }, { \"id\" : 9 , \"name\" : \"Pear\" , \"season\" : \"Fall\" , \"emoji\" : \"U+1F350\" }, { \"id\" : 2 , \"name\" : \"Strawberry\" , \"season\" : \"Spring\" , \"emoji\" : \"U+1F353\" }, { \"id\" : 7 , \"name\" : \"Watermelon\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1F349\" } ] Note When we created the signing request we created it to be used for both client/server auth. When in production its recommended to have seperate client and server certificates. Let us verify the service over http, http \" $GLOO_HTTP_PROXY_URL /api/fruits/\" Throws an error like, http: error: ConnectionError: HTTPConnectionPool ( host = '192.168.64.200.nip.io' , port = 80 ) : Max retries exceeded with url: /api/fruits/ ( Caused by NewConnectionError ( '<urllib3.connection.HTTPConnection object at 0x1027dcb20>: Failed to establish a new connection: [Errno 61] Connection refused' )) while doing a GET request to URL: http://192.168.64.200.nip.io/api/fruits/ One Way TLS \u00b6 In some use cases we are fine with one-way TLS i.e its enough the client can verify the server identity. As we learnt in the previous section that Gloo by default enables mTLS when the sslConfig secret has CA certificate in it. You can check the same using the command, kubectl get secrets -n gloo-system \" $GLOO_GATEWAY_PROXY_IP .nip.io-tls\" -o json | jq -r '.data.tls' | step base64 -d The outout of the command should have a key with name rootCa . To make the service as one-way TLS we need to enable the oneWayTls flag in the sslConfig of the Virtual Service as shown, apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : fruits-api namespace : gloo-system spec : displayName : FruitsAPI sslConfig : oneWayTls : true secretRef : name : \"${GLOO_GATEWAY_PROXY_IP}.nip.io-tls\" namespace : gloo-system virtualHost : domains : - \"${GLOO_GATEWAY_PROXY_IP}.nip.io\" routes : # Application Routes # ------------ - matchers : - prefix : /api/ routeAction : single : upstream : name : fruits-app-fruits-api-8080 namespace : gloo-system options : prefixRewrite : /v1/api/ Update the Virtual Service by runing, envsubst < $TUTORIAL_HOME /apps/microservice/fruits-api/gloo/virtual-service-onway-tls.yaml \\ | kubectl apply -f - Let us check the service over SSL , http --verify = $TUTORIAL_HOME /certs/gloo-demos-ca.crt \" $GLOO_HTTPS_PROXY_URL /api/fruits/\" Returns a list of fruits, [ { \"id\" : 8 , \"name\" : \"Apple\" , \"season\" : \"Fall\" , \"emoji\" : \"U+1F34E\" }, { \"id\" : 6 , \"name\" : \"Banana\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1F34C\" }, { \"id\" : 5 , \"name\" : \"Blueberry\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1FAD0\" }, { \"id\" : 4 , \"name\" : \"Lemon\" , \"season\" : \"Winter\" , \"emoji\" : \"U+1F34B\" }, { \"id\" : 1 , \"name\" : \"Mango\" , \"season\" : \"Spring\" , \"emoji\" : \"U+1F96D\" }, { \"id\" : 3 , \"name\" : \"Orange\" , \"season\" : \"Winter\" , \"emoji\" : \"U+1F34A\" }, { \"id\" : 9 , \"name\" : \"Pear\" , \"season\" : \"Fall\" , \"emoji\" : \"U+1F350\" }, { \"id\" : 2 , \"name\" : \"Strawberry\" , \"season\" : \"Spring\" , \"emoji\" : \"U+1F353\" }, { \"id\" : 7 , \"name\" : \"Watermelon\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1F349\" } ] As you saw now the service returned successfully with us just passing the CA alone, we can even skip passing CA by setting the --verify=no to the http call, http --verify = no \" $GLOO_HTTPS_PROXY_URL /api/fruits/\" As we have seen now to encrypt the traffic, in the next module we will see how to enable authentication. Tip For you work with with these urls over Web Browser you need to install the certificates in system/browser truststore. Check step certificate install --help for more information. With us now successfully enabled and checked mTLS and one way TLS, let us see how to enable oAuth to access control our API. cert-manager Self-Signed Certificates \u21a9","title":"Encrypt Traffic"},{"location":"encrypt/#ensure-environment","text":"We will be using few enviornment variables that we crated earlier, validate if the output of the following print statements matches your environment, echo \"\\nGloo Gateway Proxy IP: ${ GLOO_GATEWAY_PROXY_IP } \\n\" echo \"\\nMinikube IP: ${ MINIKUBE_IP } \\n\" echo \"\\nStepCA Password: ${ STEP_CA_PASSWORD } \\n\"","title":"Ensure Environment"},{"location":"encrypt/#certifcate-request","text":"As part of earlier chapter , we have step our CA and StepIssuer that helps us to create cert-manager CertificateRequests to generate the certificates. As first step of that we need to create a CSR , we can use step cli to create the CSR . Create a password file to that will be used to encrypt the keys, for the sake of this demo let use use our $STEP_CA_PASSWORD as our password to encrypt the keys, echo \" $STEP_CA_PASSWORD \" > $TUTORIAL_HOME /certs/password-file Let us create the CSR and keys, step certificate create gloo-demos --csr \\ --san \" ${ GLOO_GATEWAY_PROXY_IP } .nip.io\" \\ --san \" ${ MINIKUBE_IP } .nip.io\" \\ --san \"*- ${ GLOO_GATEWAY_PROXY_IP } .nip.io\" \\ --san \"*. ${ GLOO_GATEWAY_PROXY_IP } .nip.io\" \\ --san \"*- ${ MINIKUBE_IP } .nip.io\" \\ --san \" ${ GLOO_GATEWAY_PROXY_IP } \" \\ --san \" ${ MINIKUBE_IP } \" \\ --password-file $TUTORIAL_HOME /certs/password-file \\ $TUTORIAL_HOME /certs/gloo-demos.csr $TUTORIAL_HOME /certs/gloo-demos-key If all goes well you should have the gloo-demos.csr and gloo-demos-key files in the $TUTORIAL_HOME/certs folder.","title":"Certifcate Request"},{"location":"encrypt/#create-certificate-request","text":"Having created the CSR we are good to create the cert-manager\u2019s CertificateRequest , As first step let us base64 encode the gloo-demos CSR , export GLOO_DEMOS_CSR = $( cat $TUTORIAL_HOME /certs/gloo-demos.csr | step base64 | tr -d '\\n' ) Create the CertificateRequest , envsubst< $TUTORIAL_HOME /cluster/ssl/certificate-request.yaml | kubectl create -f - Check the status of the CertificateRequest , kubectl get certificaterequests.cert-manager.io -n step-certificates-system ${ GLOO_GATEWAY_PROXY_IP } .nip.io -o json | jq '.status.conditions[]' If all went well you should see an output like, { \"lastTransitionTime\" : \"2021-08-26T07:34:30Z\" , \"message\" : \"Certificate request has been approved by cert-manager.io\" , \"reason\" : \"cert-manager.io\" , \"status\" : \"True\" , \"type\" : \"Approved\" } { \"lastTransitionTime\" : \"2021-08-26T07:34:30Z\" , \"message\" : \"Certificate issued\" , \"reason\" : \"Issued\" , \"status\" : \"True\" , \"type\" : \"Ready\" } Wait for the certificate to be updated in the request, you can check the same via, CA Certificate can be retrieved by, kubectl get certificaterequests.cert-manager.io -n step-certificates-system ${ GLOO_GATEWAY_PROXY_IP } .nip.io -o json | jq -r '.status.ca' | step base64 -d > $TUTORIAL_HOME /certs/gloo-demos-ca.crt TLS Certificate can be retrieved by, kubectl get certificaterequests.cert-manager.io -n step-certificates-system ${ GLOO_GATEWAY_PROXY_IP } .nip.io -o json | jq -r '.status.certificate' | step base64 -d > $TUTORIAL_HOME /certs/gloo-demos.crt","title":"Create Certificate Request"},{"location":"encrypt/#verify-certificates","text":"$TUTORIAL_HOME /bin/verifyCerts.sh $TUTORIAL_HOME /certs/gloo-demos.crt $GLOO_GATEWAY_PROXY_IP .nip.io With Verification succeeded! , we are now all set to encrypt our gateway traffic.","title":"Verify Certificates"},{"location":"encrypt/#create-ssl-secret","text":"To be able to encrypt the traffic via Gloo Gateway, we need to configure the TLS certicates. The TLS certficate is configured using Kubernetes Secret. Decrypt the private key that we used to create the Certificate Signing Request, step certificate key $TUTORIAL_HOME /certs/gloo-demos-key --out = $TUTORIAL_HOME /certs/gloo-demos.key Note The command out put says its public key, but its actually decrypted private key Let us create a Kubernetes secret that we will use later to configure the TLS for Gloo Virtual Service, glooctl create secret tls $GLOO_GATEWAY_PROXY_IP .nip.io-tls \\ --certchain $TUTORIAL_HOME /certs/gloo-demos.crt \\ --privatekey = $TUTORIAL_HOME /certs/gloo-demos.key \\ --rootca = $TUTORIAL_HOME /certs/root_ca.crt +---------------------------+------+ | SECRET | TYPE | +---------------------------+------+ | 192.168.64.200.nip.io-tls | TLS | +---------------------------+------+ You can check the contents of the secret using, kubectl get secrets -n gloo-system $GLOO_GATEWAY_PROXY_IP .nip.io-tls -o json \\ | jq -r '.data.tls' \\ | step base64 -d","title":"Create SSL Secret"},{"location":"encrypt/#gloo-proxy-urls","text":"Get the Gloo proxy URLs, export GLOO_HTTPS_PROXY_URL = \"https:// ${ GLOO_GATEWAY_PROXY_IP } .nip.io\" export GLOO_HTTP_PROXY_URL = \"http:// ${ GLOO_GATEWAY_PROXY_IP } .nip.io\"","title":"Gloo Proxy URLS"},{"location":"encrypt/#encrypt-fruits-api-route","text":"As we have all the infrastructure ready to encrypt the traffic let us now configure the fruits-api Virtual Service to encrypt the traffic with our certificates.","title":"Encrypt Fruits API Route"},{"location":"encrypt/#mutual-tls-mtls","text":"Let us update the fruits-api Virtual Service to enable SSL via the sslConfig block as shown, apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : fruits-api namespace : gloo-system spec : displayName : FruitsAPI sslConfig : secretRef : name : \"${GLOO_GATEWAY_PROXY_IP}.nip.io-tls\" namespace : gloo-system virtualHost : domains : - \"${GLOO_GATEWAY_PROXY_IP}.nip.io\" routes : # Application Routes # ------------ - matchers : - prefix : /api/ routeAction : single : upstream : name : fruits-app-fruits-api-8080 namespace : gloo-system options : prefixRewrite : /v1/api/ Apply the changes by running, envsubst < $TUTORIAL_HOME /apps/microservice/fruits-api/gloo/virtual-service-mtls.yaml \\ | kubectl apply -f - Let us check the service, http --verify = $TUTORIAL_HOME /certs/gloo-demos-ca.crt \" $GLOO_HTTPS_PROXY_URL /api/fruits/\" Even though we specifed the CA the call fails with the following error, http: error: SSLError: HTTPSConnectionPool(host='192.168.64.200.nip.io', port=443): Max retries exceeded with url: /api/fruits/ (Caused by SSLError(SSLError(1, '[SSL: TLSV13_ALERT_CERTIFICATE_REQUIRED] tlsv13 alert certificate required (_ssl.c:2633)'))) while doing a GET request to URL: https://192.168.64.200.nip.io/api/fruits/ The error means we need supply the client certificate and key as part of the request.By default Envoy Proxy does enable mTLS when the Kubernetes secret has ca.crt . Since we not called it with client certificates the call fails with the error, Now let us add the client certificates and do the call again, http \\ --verify = \" $TUTORIAL_HOME /certs/gloo-demos-ca.crt\" \\ --cert = \" $TUTORIAL_HOME /certs/gloo-demos.crt\" \\ --cert-key = \" $TUTORIAL_HOME /certs/gloo-demos.key\" \\ \" $GLOO_HTTPS_PROXY_URL /api/fruits/\" The call is now sucessful returning the list of fruits, [ { \"id\" : 8 , \"name\" : \"Apple\" , \"season\" : \"Fall\" , \"emoji\" : \"U+1F34E\" }, { \"id\" : 6 , \"name\" : \"Banana\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1F34C\" }, { \"id\" : 5 , \"name\" : \"Blueberry\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1FAD0\" }, { \"id\" : 4 , \"name\" : \"Lemon\" , \"season\" : \"Winter\" , \"emoji\" : \"U+1F34B\" }, { \"id\" : 1 , \"name\" : \"Mango\" , \"season\" : \"Spring\" , \"emoji\" : \"U+1F96D\" }, { \"id\" : 3 , \"name\" : \"Orange\" , \"season\" : \"Winter\" , \"emoji\" : \"U+1F34A\" }, { \"id\" : 9 , \"name\" : \"Pear\" , \"season\" : \"Fall\" , \"emoji\" : \"U+1F350\" }, { \"id\" : 2 , \"name\" : \"Strawberry\" , \"season\" : \"Spring\" , \"emoji\" : \"U+1F353\" }, { \"id\" : 7 , \"name\" : \"Watermelon\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1F349\" } ] Note When we created the signing request we created it to be used for both client/server auth. When in production its recommended to have seperate client and server certificates. Let us verify the service over http, http \" $GLOO_HTTP_PROXY_URL /api/fruits/\" Throws an error like, http: error: ConnectionError: HTTPConnectionPool ( host = '192.168.64.200.nip.io' , port = 80 ) : Max retries exceeded with url: /api/fruits/ ( Caused by NewConnectionError ( '<urllib3.connection.HTTPConnection object at 0x1027dcb20>: Failed to establish a new connection: [Errno 61] Connection refused' )) while doing a GET request to URL: http://192.168.64.200.nip.io/api/fruits/","title":"Mutual TLS (mTLS)"},{"location":"encrypt/#one-way-tls","text":"In some use cases we are fine with one-way TLS i.e its enough the client can verify the server identity. As we learnt in the previous section that Gloo by default enables mTLS when the sslConfig secret has CA certificate in it. You can check the same using the command, kubectl get secrets -n gloo-system \" $GLOO_GATEWAY_PROXY_IP .nip.io-tls\" -o json | jq -r '.data.tls' | step base64 -d The outout of the command should have a key with name rootCa . To make the service as one-way TLS we need to enable the oneWayTls flag in the sslConfig of the Virtual Service as shown, apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : fruits-api namespace : gloo-system spec : displayName : FruitsAPI sslConfig : oneWayTls : true secretRef : name : \"${GLOO_GATEWAY_PROXY_IP}.nip.io-tls\" namespace : gloo-system virtualHost : domains : - \"${GLOO_GATEWAY_PROXY_IP}.nip.io\" routes : # Application Routes # ------------ - matchers : - prefix : /api/ routeAction : single : upstream : name : fruits-app-fruits-api-8080 namespace : gloo-system options : prefixRewrite : /v1/api/ Update the Virtual Service by runing, envsubst < $TUTORIAL_HOME /apps/microservice/fruits-api/gloo/virtual-service-onway-tls.yaml \\ | kubectl apply -f - Let us check the service over SSL , http --verify = $TUTORIAL_HOME /certs/gloo-demos-ca.crt \" $GLOO_HTTPS_PROXY_URL /api/fruits/\" Returns a list of fruits, [ { \"id\" : 8 , \"name\" : \"Apple\" , \"season\" : \"Fall\" , \"emoji\" : \"U+1F34E\" }, { \"id\" : 6 , \"name\" : \"Banana\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1F34C\" }, { \"id\" : 5 , \"name\" : \"Blueberry\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1FAD0\" }, { \"id\" : 4 , \"name\" : \"Lemon\" , \"season\" : \"Winter\" , \"emoji\" : \"U+1F34B\" }, { \"id\" : 1 , \"name\" : \"Mango\" , \"season\" : \"Spring\" , \"emoji\" : \"U+1F96D\" }, { \"id\" : 3 , \"name\" : \"Orange\" , \"season\" : \"Winter\" , \"emoji\" : \"U+1F34A\" }, { \"id\" : 9 , \"name\" : \"Pear\" , \"season\" : \"Fall\" , \"emoji\" : \"U+1F350\" }, { \"id\" : 2 , \"name\" : \"Strawberry\" , \"season\" : \"Spring\" , \"emoji\" : \"U+1F353\" }, { \"id\" : 7 , \"name\" : \"Watermelon\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1F349\" } ] As you saw now the service returned successfully with us just passing the CA alone, we can even skip passing CA by setting the --verify=no to the http call, http --verify = no \" $GLOO_HTTPS_PROXY_URL /api/fruits/\" As we have seen now to encrypt the traffic, in the next module we will see how to enable authentication. Tip For you work with with these urls over Web Browser you need to install the certificates in system/browser truststore. Check step certificate install --help for more information. With us now successfully enabled and checked mTLS and one way TLS, let us see how to enable oAuth to access control our API. cert-manager Self-Signed Certificates \u21a9","title":"One Way TLS"},{"location":"gloo-resources/","text":"Integrate with Gloo Edge \u00b6 We have now deployed the Fruits API, in the up coming sections we will create the necessary Gloo Edge resources that will allow configure and access the API. To have more understanding on core concepts check the Gloo Edge documentation . At the end of this chapter you would have known how to: Discover Upstreams Create Virtual Services Discover Upstreams \u00b6 The Gloo Edge installation that as done as part of the demo is enabled to do auto discovery of the upstreams. The Fruits API that we deployed earlier would have been discovered as fruits-app-fruits-api-8080 . Let us check to see if thats available, glooctl get upstream fruits-app-fruits-api-8080 -----------------------------------------------------------------------------+ | UPSTREAM | TYPE | STATUS | DETAILS | -----------------------------------------------------------------------------+ | fruits-app-fruits-api-8080 | Kubernetes | Accepted | svc name: fruits-api | | | | | svc namespace: fruits-app | | | | | port: 8080 | | | | | | -----------------------------------------------------------------------------+ Route \u00b6 A Route is a Gloo Virutal Service resource that allows us to access the API i.e. the services that are deployed on to Kubernetes. apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : fruits-api namespace : gloo-system spec : displayName : FruitsAPI virtualHost : domains : # (1) - \"$GLOO_GATEWAY_PROXY_IP.nip.io\" routes : # Application Routes # ------------ - matchers : - prefix : /api/ #(2) routeAction : single : upstream : #(3) name : fruits-app-fruits-api-8080 namespace : gloo-system options : prefixRewrite : /v1/api/ #(4) Domains that will be allowed by the Gateway The prefix to access the API The upstream that wil be used to route the request The url rewrite to do before passing the request to backend Let us create the virutal service, envsubst < $TUTORIAL_HOME /apps/microservice/fruits-api/gloo/virtual-service.yaml | kubectl apply -n gloo-system -f - Check the status of the virtual service glooctl get vs fruits-api ---------------------------------------------------------------------------------------------- | VIRTUAL SERVICE | DISPLAY NAME | DOMAINS | SSL | STATUS | LISTENERPLUGINS | ROUTES | ---------------------------------------------------------------------------------------------- | fruits-api | | * | none | Accepted | | / -> 1 destinations | ---------------------------------------------------------------------------------------------- Invoke API \u00b6 We need to use the Gloo proxy to access the API, we can use glooctl to get the proxy URL, export GLOO_PROXY_URL = \"http:// $GLOO_GATEWAY_PROXY_IP .nip.io\" Check if the API is accessible, http $GLOO_PROXY_URL /api/fruits/ The command should return a list of fruits as shown, [ { \"id\" : 8 , \"name\" : \"Apple\" , \"season\" : \"Fall\" , \"emoji\" : \"U+1F34E\" }, { \"id\" : 6 , \"name\" : \"Banana\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1F34C\" }, { \"id\" : 5 , \"name\" : \"Blueberry\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1FAD0\" }, { \"id\" : 4 , \"name\" : \"Lemon\" , \"season\" : \"Winter\" , \"emoji\" : \"U+1F34B\" }, { \"id\" : 1 , \"name\" : \"Mango\" , \"season\" : \"Spring\" , \"emoji\" : \"U+1F96D\" }, { \"id\" : 3 , \"name\" : \"Orange\" , \"season\" : \"Winter\" , \"emoji\" : \"U+1F34A\" }, { \"id\" : 9 , \"name\" : \"Pear\" , \"season\" : \"Fall\" , \"emoji\" : \"U+1F350\" }, { \"id\" : 2 , \"name\" : \"Strawberry\" , \"season\" : \"Spring\" , \"emoji\" : \"U+1F353\" }, { \"id\" : 7 , \"name\" : \"Watermelon\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1F349\" } ]","title":"Create Gloo Resources"},{"location":"gloo-resources/#integrate-with-gloo-edge","text":"We have now deployed the Fruits API, in the up coming sections we will create the necessary Gloo Edge resources that will allow configure and access the API. To have more understanding on core concepts check the Gloo Edge documentation . At the end of this chapter you would have known how to: Discover Upstreams Create Virtual Services","title":"Integrate with Gloo Edge"},{"location":"gloo-resources/#discover-upstreams","text":"The Gloo Edge installation that as done as part of the demo is enabled to do auto discovery of the upstreams. The Fruits API that we deployed earlier would have been discovered as fruits-app-fruits-api-8080 . Let us check to see if thats available, glooctl get upstream fruits-app-fruits-api-8080 -----------------------------------------------------------------------------+ | UPSTREAM | TYPE | STATUS | DETAILS | -----------------------------------------------------------------------------+ | fruits-app-fruits-api-8080 | Kubernetes | Accepted | svc name: fruits-api | | | | | svc namespace: fruits-app | | | | | port: 8080 | | | | | | -----------------------------------------------------------------------------+","title":"Discover Upstreams"},{"location":"gloo-resources/#route","text":"A Route is a Gloo Virutal Service resource that allows us to access the API i.e. the services that are deployed on to Kubernetes. apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : fruits-api namespace : gloo-system spec : displayName : FruitsAPI virtualHost : domains : # (1) - \"$GLOO_GATEWAY_PROXY_IP.nip.io\" routes : # Application Routes # ------------ - matchers : - prefix : /api/ #(2) routeAction : single : upstream : #(3) name : fruits-app-fruits-api-8080 namespace : gloo-system options : prefixRewrite : /v1/api/ #(4) Domains that will be allowed by the Gateway The prefix to access the API The upstream that wil be used to route the request The url rewrite to do before passing the request to backend Let us create the virutal service, envsubst < $TUTORIAL_HOME /apps/microservice/fruits-api/gloo/virtual-service.yaml | kubectl apply -n gloo-system -f - Check the status of the virtual service glooctl get vs fruits-api ---------------------------------------------------------------------------------------------- | VIRTUAL SERVICE | DISPLAY NAME | DOMAINS | SSL | STATUS | LISTENERPLUGINS | ROUTES | ---------------------------------------------------------------------------------------------- | fruits-api | | * | none | Accepted | | / -> 1 destinations | ----------------------------------------------------------------------------------------------","title":"Route"},{"location":"gloo-resources/#invoke-api","text":"We need to use the Gloo proxy to access the API, we can use glooctl to get the proxy URL, export GLOO_PROXY_URL = \"http:// $GLOO_GATEWAY_PROXY_IP .nip.io\" Check if the API is accessible, http $GLOO_PROXY_URL /api/fruits/ The command should return a list of fruits as shown, [ { \"id\" : 8 , \"name\" : \"Apple\" , \"season\" : \"Fall\" , \"emoji\" : \"U+1F34E\" }, { \"id\" : 6 , \"name\" : \"Banana\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1F34C\" }, { \"id\" : 5 , \"name\" : \"Blueberry\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1FAD0\" }, { \"id\" : 4 , \"name\" : \"Lemon\" , \"season\" : \"Winter\" , \"emoji\" : \"U+1F34B\" }, { \"id\" : 1 , \"name\" : \"Mango\" , \"season\" : \"Spring\" , \"emoji\" : \"U+1F96D\" }, { \"id\" : 3 , \"name\" : \"Orange\" , \"season\" : \"Winter\" , \"emoji\" : \"U+1F34A\" }, { \"id\" : 9 , \"name\" : \"Pear\" , \"season\" : \"Fall\" , \"emoji\" : \"U+1F350\" }, { \"id\" : 2 , \"name\" : \"Strawberry\" , \"season\" : \"Spring\" , \"emoji\" : \"U+1F353\" }, { \"id\" : 7 , \"name\" : \"Watermelon\" , \"season\" : \"Summer\" , \"emoji\" : \"U+1F349\" } ]","title":"Invoke API"},{"location":"pki/","text":"Overview \u00b6 As part of this tutorial we will use the step to automate the setup local private CA. We will then use this CA to issue the certificates that we will use with Gloo as part of the other module exercises. At the end of this chapter you would have setup, Cert Manager smallstep CA smallstep Step Issuer Ensure Environment \u00b6 export STEP_CA_PASSWORD = password export STEP_PROVISIONER_NAME = mygloodemos@example.com Download all Cert Manager \u00b6 Download and install cert-manager . Ensure that cert-manager is added to the system-path. Verify cert-manager : kubectl cert-manager version --short The command should show an output like Client Version: v1.5.1 error: could not detect the cert-manager version: the cert-manager CRDs are not yet installed on the Kubernetes API server Install Cert Manager \u00b6 The error shown in the command is OK as we are yet to install the cert-manager in the cluster. Let us install by running, kubectl cert-manager x install Now running the version command kubectl cert-manager version --short again should show an output like: Client Version: v1.5.1 Server Version: v1.5.3 Deploy step-certificates \u00b6 We can deploy the step-certificates to our existing kubernetes cluster using helm . Add step-certificates helm repository, helm repo add smallstep https://smallstep.github.io/helm-charts/ helm repo update Update helm values file, envsubst < $TUTORIAL_HOME /cluster/step-ca/values.tpl > $TUTORIAL_HOME /cluster/step-ca/values.yaml Create the namespace to install step-certificates , kubectl create ns step-certificates-system Install step-certificates from repository, helm install step-certificates smallstep/step-certificates \\ -n step-certificates-system \\ -f $TUTORIAL_HOME /cluster/step-ca/values.yaml \\ --wait Configure Step CA \u00b6 By default the step-ca issues TLS certicates that are valid only for 24 hours . For the tutorial purpose we will reconfigure it to be 720 hours(30 days) . For more information on the step configuration check the documentation . CA_JSON = $( kubectl get cm -n step-certificates-system step-certificates-config -o json | jq -r '.data[\"ca.json\"]' | jq -c '.authority.claims += { \"maxTLSCertDuration\": \"720h\" }' | jq -Rs . ) Update the step-certificates-config , kubectl patch configmap/step-certificates-config \\ -n step-certificates-system \\ --type merge \\ -p \"{\\\"data\\\":{\\\"ca.json\\\": $CA_JSON }}\" Lets restart the statefulset to make sure the updated configuration takes effect, kubectl rollout restart -n step-certificates-system statefulset/step-certificates Wait for the stateful set step-certificates to be up kubectl rollout status -n step-certificates-system statefulset/step-certificates --timeout = 60s Install Step Issuer \u00b6 We will use step-issuer as way to automate the certificate requests. Create the namespace to install step-issuer-system , kubectl create ns step-issuer-system helm install -n step-issuer-system step-issuer smallstep/step-issuer --wait Deploy Step Issuer \u00b6 In order to use the step-certificates CA we need to setup a StepIssuer to act as cert-manager issuer 1 . The step-issuer needs few credentials from the step-certficates that we deployed earlier. For convinience let us extract them and store in environment variables, Save the root CA file, kubectl get -n step-certificates-system -o jsonpath = \"{.data['root_ca\\.crt']}\" configmaps/step-certificates-certs > $TUTORIAL_HOME /certs/root_ca.crt You can inspect the root ca certficate by, step certificate inspect $TUTORIAL_HOME /certs/root_ca.crt Get CA root certifiate as PEM, export ROOT_CA_CERT = $( kubectl get -n step-certificates-system -o jsonpath = \"{.data['root_ca\\.crt']}\" configmaps/step-certificates-certs | step base64 | tr -d '\\n' ) Get the Provisioner Key ID, export PROVISIONER_KID = $( kubectl get -n step-certificates-system -o jsonpath = \"{.data['ca\\.json']}\" configmaps/step-certificates-config \\ | jq -r --arg NAME \" $STEP_PROVISIONER_NAME \" \\ '.authority.provisioners | .[] | select(.name == $NAME) | .key.kid' | tr -d '\\n' ) Create the Issuer, envsubst < $TUTORIAL_HOME /cluster/step-ca/issuer.yaml | kubectl apply -f - Wait for the issuer to be ready, while [ \" $( kubectl get stepissuers.certmanager.step.sm -n step-certificates-system step-issuer -o json | jq -r '.status.conditions|.[]|select(.type == \"Ready\")|.status' ) \" ! = \"True\" ] ; do echo \"Waiting for StepIssuer to be ready\" sleep .3 done Configure Gloo Edge \u00b6 We have now setup the Certifcate Authority and Issuer. We need to update the Gloo Edge deployment to trust the CA, Create a secret with our custom CA root certificate, envsubst < $TUTORIAL_HOME /cluster/gloo/trusted-ca.yaml | kubectl apply -n gloo-system -f - As we need to ensure that Gloo extauth uses our custom CA, we need to patch the Gloo\u2019 extauth deployment and inject our root CA. export GLOO_EE_IMAGE = $( kubectl get -n gloo-system deployments.apps extauth -o json | jq -r '.spec.template.spec.containers | .[] | select(.name == \"extauth\") | .image' ) Create the patch, envsubst < $TUTORIAL_HOME /cluster/gloo/extauth-patch-template > $TUTORIAL_HOME /cluster/gloo/extauth-patch.json Run the command to patch the extauth deployment, kubectl patch deployment -n gloo-system extauth --type = 'json' -p \" $( cat $TUTORIAL_HOME /cluster/gloo/extauth-patch.json ) \" Verify if the patch was successful, exit_code = $( kubectl get pods -n gloo-system -l gloo = extauth -o json | jq '.items[0].status.initContainerStatuses|.[]|select(.name==\"add-ca-cert\")|.state.terminated.exitCode' ) exit_reason = $( kubectl get pods -n gloo-system -l gloo = extauth -o json | jq '.items[0].status.initContainerStatuses|.[]|select(.name==\"add-ca-cert\")|.state.terminated.reason' ) echo \"Exit Code: $exit_code \" echo \"Exit Reason: $exit_reason \" You should see the following output, Exit Code: 0 Exit Reason: \"Completed\" https://cert-manager.io/docs/configuration/external/ \u21a9","title":"Public Key Infrastructure"},{"location":"pki/#overview","text":"As part of this tutorial we will use the step to automate the setup local private CA. We will then use this CA to issue the certificates that we will use with Gloo as part of the other module exercises. At the end of this chapter you would have setup, Cert Manager smallstep CA smallstep Step Issuer","title":"Overview"},{"location":"pki/#ensure-environment","text":"export STEP_CA_PASSWORD = password export STEP_PROVISIONER_NAME = mygloodemos@example.com","title":"Ensure Environment"},{"location":"pki/#download-all-cert-manager","text":"Download and install cert-manager . Ensure that cert-manager is added to the system-path. Verify cert-manager : kubectl cert-manager version --short The command should show an output like Client Version: v1.5.1 error: could not detect the cert-manager version: the cert-manager CRDs are not yet installed on the Kubernetes API server","title":"Download all Cert Manager"},{"location":"pki/#install-cert-manager","text":"The error shown in the command is OK as we are yet to install the cert-manager in the cluster. Let us install by running, kubectl cert-manager x install Now running the version command kubectl cert-manager version --short again should show an output like: Client Version: v1.5.1 Server Version: v1.5.3","title":"Install Cert Manager"},{"location":"pki/#deploy-step-certificates","text":"We can deploy the step-certificates to our existing kubernetes cluster using helm . Add step-certificates helm repository, helm repo add smallstep https://smallstep.github.io/helm-charts/ helm repo update Update helm values file, envsubst < $TUTORIAL_HOME /cluster/step-ca/values.tpl > $TUTORIAL_HOME /cluster/step-ca/values.yaml Create the namespace to install step-certificates , kubectl create ns step-certificates-system Install step-certificates from repository, helm install step-certificates smallstep/step-certificates \\ -n step-certificates-system \\ -f $TUTORIAL_HOME /cluster/step-ca/values.yaml \\ --wait","title":"Deploy step-certificates"},{"location":"pki/#configure-step-ca","text":"By default the step-ca issues TLS certicates that are valid only for 24 hours . For the tutorial purpose we will reconfigure it to be 720 hours(30 days) . For more information on the step configuration check the documentation . CA_JSON = $( kubectl get cm -n step-certificates-system step-certificates-config -o json | jq -r '.data[\"ca.json\"]' | jq -c '.authority.claims += { \"maxTLSCertDuration\": \"720h\" }' | jq -Rs . ) Update the step-certificates-config , kubectl patch configmap/step-certificates-config \\ -n step-certificates-system \\ --type merge \\ -p \"{\\\"data\\\":{\\\"ca.json\\\": $CA_JSON }}\" Lets restart the statefulset to make sure the updated configuration takes effect, kubectl rollout restart -n step-certificates-system statefulset/step-certificates Wait for the stateful set step-certificates to be up kubectl rollout status -n step-certificates-system statefulset/step-certificates --timeout = 60s","title":"Configure Step CA"},{"location":"pki/#install-step-issuer","text":"We will use step-issuer as way to automate the certificate requests. Create the namespace to install step-issuer-system , kubectl create ns step-issuer-system helm install -n step-issuer-system step-issuer smallstep/step-issuer --wait","title":"Install Step Issuer"},{"location":"pki/#deploy-step-issuer","text":"In order to use the step-certificates CA we need to setup a StepIssuer to act as cert-manager issuer 1 . The step-issuer needs few credentials from the step-certficates that we deployed earlier. For convinience let us extract them and store in environment variables, Save the root CA file, kubectl get -n step-certificates-system -o jsonpath = \"{.data['root_ca\\.crt']}\" configmaps/step-certificates-certs > $TUTORIAL_HOME /certs/root_ca.crt You can inspect the root ca certficate by, step certificate inspect $TUTORIAL_HOME /certs/root_ca.crt Get CA root certifiate as PEM, export ROOT_CA_CERT = $( kubectl get -n step-certificates-system -o jsonpath = \"{.data['root_ca\\.crt']}\" configmaps/step-certificates-certs | step base64 | tr -d '\\n' ) Get the Provisioner Key ID, export PROVISIONER_KID = $( kubectl get -n step-certificates-system -o jsonpath = \"{.data['ca\\.json']}\" configmaps/step-certificates-config \\ | jq -r --arg NAME \" $STEP_PROVISIONER_NAME \" \\ '.authority.provisioners | .[] | select(.name == $NAME) | .key.kid' | tr -d '\\n' ) Create the Issuer, envsubst < $TUTORIAL_HOME /cluster/step-ca/issuer.yaml | kubectl apply -f - Wait for the issuer to be ready, while [ \" $( kubectl get stepissuers.certmanager.step.sm -n step-certificates-system step-issuer -o json | jq -r '.status.conditions|.[]|select(.type == \"Ready\")|.status' ) \" ! = \"True\" ] ; do echo \"Waiting for StepIssuer to be ready\" sleep .3 done","title":"Deploy Step Issuer"},{"location":"pki/#configure-gloo-edge","text":"We have now setup the Certifcate Authority and Issuer. We need to update the Gloo Edge deployment to trust the CA, Create a secret with our custom CA root certificate, envsubst < $TUTORIAL_HOME /cluster/gloo/trusted-ca.yaml | kubectl apply -n gloo-system -f - As we need to ensure that Gloo extauth uses our custom CA, we need to patch the Gloo\u2019 extauth deployment and inject our root CA. export GLOO_EE_IMAGE = $( kubectl get -n gloo-system deployments.apps extauth -o json | jq -r '.spec.template.spec.containers | .[] | select(.name == \"extauth\") | .image' ) Create the patch, envsubst < $TUTORIAL_HOME /cluster/gloo/extauth-patch-template > $TUTORIAL_HOME /cluster/gloo/extauth-patch.json Run the command to patch the extauth deployment, kubectl patch deployment -n gloo-system extauth --type = 'json' -p \" $( cat $TUTORIAL_HOME /cluster/gloo/extauth-patch.json ) \" Verify if the patch was successful, exit_code = $( kubectl get pods -n gloo-system -l gloo = extauth -o json | jq '.items[0].status.initContainerStatuses|.[]|select(.name==\"add-ca-cert\")|.state.terminated.exitCode' ) exit_reason = $( kubectl get pods -n gloo-system -l gloo = extauth -o json | jq '.items[0].status.initContainerStatuses|.[]|select(.name==\"add-ca-cert\")|.state.terminated.reason' ) echo \"Exit Code: $exit_code \" echo \"Exit Reason: $exit_reason \" You should see the following output, Exit Code: 0 Exit Reason: \"Completed\" https://cert-manager.io/docs/configuration/external/ \u21a9","title":"Configure Gloo Edge"},{"location":"rate-limit/","text":"Gloo Edge::Rate Limit \u00b6 At the end of this chapter you would have known how to: Configure Rate Limiting As part of this section we will configure Rate limiting . apiVersion : ratelimit.solo.io/v1alpha1 kind : RateLimitConfig metadata : name : global-limit namespace : gloo-system spec : raw : descriptors : - key : generic_key value : count rateLimit : requestsPerUnit : 10 #(1) unit : MINUTE #(1) rateLimits : - actions : - genericKey : descriptorValue : count Number of requests The duration for the request threshold, is this case 1 minute Let us apply the rate limiting configuration, kubectl apply -n gloo-system -f $TUTORIAL_HOME /apps/microservice/fruits-api/gloo/ratelimit-config.yaml Update the service with ratelimit, kubectl apply -n gloo-system -f $TUTORIAL_HOME /apps/microservice/fruits-api/gloo/virtual-service-ratelimit.yaml Let us now send requests to the API, with our current configuration we should start to get HTTP 429 once we exceed 10 requests, $TUTORIAL_HOME /bin/poll.sh Wait for a minute more to try polling again to see the requests getting executed successfully. TODO Rate Limite for Authenticated/UnAuthenticated users","title":"Rate Limit"},{"location":"rate-limit/#gloo-edgerate-limit","text":"At the end of this chapter you would have known how to: Configure Rate Limiting As part of this section we will configure Rate limiting . apiVersion : ratelimit.solo.io/v1alpha1 kind : RateLimitConfig metadata : name : global-limit namespace : gloo-system spec : raw : descriptors : - key : generic_key value : count rateLimit : requestsPerUnit : 10 #(1) unit : MINUTE #(1) rateLimits : - actions : - genericKey : descriptorValue : count Number of requests The duration for the request threshold, is this case 1 minute Let us apply the rate limiting configuration, kubectl apply -n gloo-system -f $TUTORIAL_HOME /apps/microservice/fruits-api/gloo/ratelimit-config.yaml Update the service with ratelimit, kubectl apply -n gloo-system -f $TUTORIAL_HOME /apps/microservice/fruits-api/gloo/virtual-service-ratelimit.yaml Let us now send requests to the API, with our current configuration we should start to get HTTP 429 once we exceed 10 requests, $TUTORIAL_HOME /bin/poll.sh Wait for a minute more to try polling again to see the requests getting executed successfully. TODO Rate Limite for Authenticated/UnAuthenticated users","title":"Gloo Edge::Rate Limit"},{"location":"setup/","text":"At the end of this chapter you would have, Installed Gloo Edge Enterprise Ensure Environment \u00b6 Make sure you have the Gloo Enterprise License Key before proceeding to install. Export the license key to variable, export GLOO_LICENSE_KEY = <your Gloo EE License Key> Download glooctl \u00b6 Download and install latest glooctl by running, curl -sL https://run.solo.io/gloo/install | sh Add glooctl to the system path, export PATH = $HOME /.gloo/bin: $PATH Prepare Gloo Edge install \u00b6 Create the gloo-system namespace to install Gloo Edge , kubectl create namespace gloo-system Add helm repository, helm repo add glooe https://storage.googleapis.com/gloo-ee-helm helm repo update Get the latest Gloo Edge version, export GLOO_EE_VERSION = $( helm search repo glooe -ojson | jq -r '.[0].version' ) Install Gloo Edge \u00b6 Now we are all set to install Gloo Edge, Gloo Edge proxy is a Kubernetes service of type LoadBalancer , for the purpose of this blog we will configure it to be of type NodePort so that we can access from the host machine. helm install gloo glooe/gloo-ee --namespace gloo-system \\ --set license_key = $GLOO_LICENSE_KEY \\ --wait Note You can safely ignore the helm warnings It will take few minutes for the Gloo Edge to be installed and ready Verify Install \u00b6 Once all the gloo install is complete, do a sanity check by running, glooctl check A successful gloo edge installation should show an output like, Checking deployments... OK Checking pods... OK Checking upstreams... OK Checking upstream groups... OK Checking auth configs... OK Checking rate limit configs... OK Checking VirtualHostOptions... OK Checking RouteOptions... OK Checking secrets... OK Checking virtual services... OK Checking gateways... OK Checking proxies... OK Checking rate limit server... OK No problems detected. I0818 09:29:26.773174 6734 request.go:645] Throttling request took 1.041899775s, request: GET:https://127.0.0.1:57778/apis/storage.k8s.io/v1?timeout=32s Detected Gloo Federation! Retrieve the Gloo Gateway Proxy IP address, we will need it to configure the root CA certificates, export GLOO_GATEWAY_PROXY_IP = $( glooctl proxy address | cut -f1 -d ':' )","title":"Setup"},{"location":"setup/#ensure-environment","text":"Make sure you have the Gloo Enterprise License Key before proceeding to install. Export the license key to variable, export GLOO_LICENSE_KEY = <your Gloo EE License Key>","title":"Ensure Environment"},{"location":"setup/#download-glooctl","text":"Download and install latest glooctl by running, curl -sL https://run.solo.io/gloo/install | sh Add glooctl to the system path, export PATH = $HOME /.gloo/bin: $PATH","title":"Download glooctl"},{"location":"setup/#prepare-gloo-edge-install","text":"Create the gloo-system namespace to install Gloo Edge , kubectl create namespace gloo-system Add helm repository, helm repo add glooe https://storage.googleapis.com/gloo-ee-helm helm repo update Get the latest Gloo Edge version, export GLOO_EE_VERSION = $( helm search repo glooe -ojson | jq -r '.[0].version' )","title":"Prepare Gloo Edge install"},{"location":"setup/#install-gloo-edge","text":"Now we are all set to install Gloo Edge, Gloo Edge proxy is a Kubernetes service of type LoadBalancer , for the purpose of this blog we will configure it to be of type NodePort so that we can access from the host machine. helm install gloo glooe/gloo-ee --namespace gloo-system \\ --set license_key = $GLOO_LICENSE_KEY \\ --wait Note You can safely ignore the helm warnings It will take few minutes for the Gloo Edge to be installed and ready","title":"Install Gloo Edge"},{"location":"setup/#verify-install","text":"Once all the gloo install is complete, do a sanity check by running, glooctl check A successful gloo edge installation should show an output like, Checking deployments... OK Checking pods... OK Checking upstreams... OK Checking upstream groups... OK Checking auth configs... OK Checking rate limit configs... OK Checking VirtualHostOptions... OK Checking RouteOptions... OK Checking secrets... OK Checking virtual services... OK Checking gateways... OK Checking proxies... OK Checking rate limit server... OK No problems detected. I0818 09:29:26.773174 6734 request.go:645] Throttling request took 1.041899775s, request: GET:https://127.0.0.1:57778/apis/storage.k8s.io/v1?timeout=32s Detected Gloo Federation! Retrieve the Gloo Gateway Proxy IP address, we will need it to configure the root CA certificates, export GLOO_GATEWAY_PROXY_IP = $( glooctl proxy address | cut -f1 -d ':' )","title":"Verify Install"},{"location":"tools-and-sources/","text":"We will be using the following tools as part of the tutorial. Please have them installed and configured before proceeding further. Download Tools \u00b6 Tool macos linux windows minikube Install Install Install helm brew install helm Install choco install kubernetes-helm glooctl Download Download Download jq brew install jq Download chocolatey install jq kubectl brew install kubectl Download choco install kubernetes-cli kustomize brew install kustomize Download choco install kustomize step cli brew install step Download Download Important You will need Gloo Edge Enterprise License Key to run the demo exercises. If you dont have one, get a trial license from solo.io . Demo Sources \u00b6 Clone the demo sources from the GitHub respository, git clone https://github.com/kameshsampath/gloo-security-tutorial cd gloo-security-tutorial For convinience, we will refer the clone demo sources folder as $TUTORIAL_HOME , export PROFILE_NAME = \"gloo-tutorial\" export TUTORIAL_HOME = \" $PWD \" Kubernetes Cluster Setup \u00b6 As part of this tutorial we will use minikube as our target cluster. To create the minikube cluster run the following command, $TUTORIAL_HOME /bin/start-minikube.sh Metallb \u00b6 As we will need to access the Gloo Gateway proxy on the host, we will use metallb addon to minikube. Enable the metallb addon by running, minikube -p $PROFILE_NAME addons enable metallb Wait for the metallb deployment to be ready, kubectl rollout status -n metallb-system deploy/controller --timeout = 60s Get the minikube IP by running the command, export MINIKUBE_IP = $( minikube -p $PROFILE_NAME ip ) echo $MINIKUBE_IP Once the addon is enabled run the following command to configure the LoadBalancer IP range, minikube -p $PROFILE_NAME addons configure metallb Important Ensure that the Enter Load Balancer Start IP and Enter Load Balancer End IP is in the same subnet of $MINIKUBE_IP . For an example if $MINIKUBE_IP is 192.168.64.20 , the set the Enter Load Balancer Start IP to be something like 192.168.64.200 and Enter Load Balancer End IP to be something like 192.168.64.250 , that will give enough slack for you to create new minikube clusters without any ip clash. Once you have setup minikube you are all set to move to next chapter to setup the certificate authority.","title":"Tools and Sources"},{"location":"tools-and-sources/#download-tools","text":"Tool macos linux windows minikube Install Install Install helm brew install helm Install choco install kubernetes-helm glooctl Download Download Download jq brew install jq Download chocolatey install jq kubectl brew install kubectl Download choco install kubernetes-cli kustomize brew install kustomize Download choco install kustomize step cli brew install step Download Download Important You will need Gloo Edge Enterprise License Key to run the demo exercises. If you dont have one, get a trial license from solo.io .","title":"Download Tools"},{"location":"tools-and-sources/#demo-sources","text":"Clone the demo sources from the GitHub respository, git clone https://github.com/kameshsampath/gloo-security-tutorial cd gloo-security-tutorial For convinience, we will refer the clone demo sources folder as $TUTORIAL_HOME , export PROFILE_NAME = \"gloo-tutorial\" export TUTORIAL_HOME = \" $PWD \"","title":"Demo Sources"},{"location":"tools-and-sources/#kubernetes-cluster-setup","text":"As part of this tutorial we will use minikube as our target cluster. To create the minikube cluster run the following command, $TUTORIAL_HOME /bin/start-minikube.sh","title":"Kubernetes Cluster Setup"},{"location":"tools-and-sources/#metallb","text":"As we will need to access the Gloo Gateway proxy on the host, we will use metallb addon to minikube. Enable the metallb addon by running, minikube -p $PROFILE_NAME addons enable metallb Wait for the metallb deployment to be ready, kubectl rollout status -n metallb-system deploy/controller --timeout = 60s Get the minikube IP by running the command, export MINIKUBE_IP = $( minikube -p $PROFILE_NAME ip ) echo $MINIKUBE_IP Once the addon is enabled run the following command to configure the LoadBalancer IP range, minikube -p $PROFILE_NAME addons configure metallb Important Ensure that the Enter Load Balancer Start IP and Enter Load Balancer End IP is in the same subnet of $MINIKUBE_IP . For an example if $MINIKUBE_IP is 192.168.64.20 , the set the Enter Load Balancer Start IP to be something like 192.168.64.200 and Enter Load Balancer End IP to be something like 192.168.64.250 , that will give enough slack for you to create new minikube clusters without any ip clash. Once you have setup minikube you are all set to move to next chapter to setup the certificate authority.","title":"Metallb"},{"location":"troubleshooting/","text":"Certifcate Request failed \u00b6 When CertificatRequest fails, e.g. kubectl get certificaterequests.cert-manager.io -n step-certificates-system ${ FRUITS_UI_IP } .nip.io -o json | jq '.status.conditions[]' If the command gives an output like, { \"lastTransitionTime\" : \"2021-09-02T04:19:17Z\" , \"message\" : \"Certificate request has been approved by cert-manager.io\" , \"reason\" : \"cert-manager.io\" , \"status\" : \"True\" , \"type\" : \"Approved\" } { \"lastTransitionTime\" : \"2021-09-02T04:19:17Z\" , \"message\" : \"Failed to sign certificate request: The request lacked necessary authorization to be completed. Please see the certificate authority logs for more info.\" , \"reason\" : \"Failed\" , \"status\" : \"False\" , \"type\" : \"Ready\" } Check the certificate authority logs for messages in our case the CA step-ca and lets check its logs, stern -n step-certificates-system step-certificates-0 -i 'level=warning|error' Tip stern is useful kubernetes log viewer","title":"Troubleshooting"},{"location":"troubleshooting/#certifcate-request-failed","text":"When CertificatRequest fails, e.g. kubectl get certificaterequests.cert-manager.io -n step-certificates-system ${ FRUITS_UI_IP } .nip.io -o json | jq '.status.conditions[]' If the command gives an output like, { \"lastTransitionTime\" : \"2021-09-02T04:19:17Z\" , \"message\" : \"Certificate request has been approved by cert-manager.io\" , \"reason\" : \"cert-manager.io\" , \"status\" : \"True\" , \"type\" : \"Approved\" } { \"lastTransitionTime\" : \"2021-09-02T04:19:17Z\" , \"message\" : \"Failed to sign certificate request: The request lacked necessary authorization to be completed. Please see the certificate authority logs for more info.\" , \"reason\" : \"Failed\" , \"status\" : \"False\" , \"type\" : \"Ready\" } Check the certificate authority logs for messages in our case the CA step-ca and lets check its logs, stern -n step-certificates-system step-certificates-0 -i 'level=warning|error' Tip stern is useful kubernetes log viewer","title":"Certifcate Request failed"},{"location":"ui/","text":"At the end of this chapter you would have: Create Certifiates for UI Application Deployed Fruits Application UI Configure Gloo Virtual Service Ensure environment \u00b6 Lets ensure that we have all the required environment variables set for this module, echo \"\\n Tutorial Home: $TUTORIAL_HOME \\n\" echo \"\\n Gloo Gateway Proxy IP: $GLOO_GATEWAY_PROXY_IP \\n\" echo \"\\n Gloo Proxy HTTP URL: $GLOO_PROXY_HTTP_URL \\n\" echo \"\\n Gloo Proxy HTTP URL: $GLOO_PROXY_HTTPS_URL \\n\" echo \"\\n ROOT CA Cert: $ROOT_CA_CERT \\n\" Prepare Fruits UI Deployment \u00b6 Create Namespace \u00b6 kubectl create ns ui Fruits UI SSL Certificates \u00b6 To create the Fruits UI SSL certificate, we need to know the Fruits UI service LoadBalancer IP. To get the LB IP let us create the Fruits UI service, kustomize build $TUTORIAL_HOME /apps/microservice/ui/overlays/minikube | envsubst | kubectl apply -f - Get the Fruits UI LoadBalancer IP, export FRUITS_UI_IP = $( kubectl get svc -n ui fruits-app-ui -ojson | jq -r '.status.loadBalancer.ingress[0].ip' ) Note As you would have observed the deployment fruits-app-ui is not up as we have set the replicas to 0 . We will scale the application once we have certificates ready to be used. Create Fruits UI CSR \u00b6 Let us create the CSR and keys, step certificate create fruits-ui --csr \\ --san \" ${ FRUITS_UI_IP } .nip.io\" \\ --san \"*- ${ FRUITS_UI_IP } .nip.io\" \\ --san \"*. ${ FRUITS_UI_IP } .nip.io\" \\ --san \" ${ FRUITS_UI_IP } \" \\ --password-file $TUTORIAL_HOME /certs/password-file \\ $TUTORIAL_HOME /certs/fruits-ui.csr $TUTORIAL_HOME /certs/fruits-ui-key If all goes well you should have the fruits-ui.csr and fruits-ui-key files in the $TUTORIAL_HOME/certs folder. Create Certificate Request \u00b6 Having created the CSR we are good to create the cert-manager\u2019s CertificateRequest , As first step let us base64 encode the fruits-ui CSR, export FRUITS_UI_CSR = $( cat $TUTORIAL_HOME /certs/fruits-ui.csr | step base64 | tr -d '\\n' ) Create the CertificateRequest , envsubst< $TUTORIAL_HOME /apps/microservice/ui/certificate-request.yaml | kubectl create -f - Check the status of the CertificateRequest , kubectl get certificaterequests.cert-manager.io -n step-certificates-system ${ FRUITS_UI_IP } .nip.io -o json | jq '.status.conditions[]' If all went well you should see an output like, { \"lastTransitionTime\" : \"2021-08-27T16:15:14Z\" , \"message\" : \"Certificate request has been approved by cert-manager.io\" , \"reason\" : \"cert-manager.io\" , \"status\" : \"True\" , \"type\" : \"Approved\" } { \"lastTransitionTime\" : \"2021-08-27T16:15:14Z\" , \"message\" : \"Certificate issued\" , \"reason\" : \"Issued\" , \"status\" : \"True\" , \"type\" : \"Ready\" } Wait for the certificate to be updated in the request, you can check the same via, CA Certificate can be retrieved by, kubectl get certificaterequests.cert-manager.io -n step-certificates-system ${ FRUITS_UI_IP } .nip.io -o json | jq -r '.status.ca' | step base64 -d > $TUTORIAL_HOME /certs/fruits-ui-ca.crt TLS Certificate can be retrieved by, kubectl get certificaterequests.cert-manager.io -n step-certificates-system ${ FRUITS_UI_IP } .nip.io -o json | jq -r '.status.certificate' | step base64 -d > $TUTORIAL_HOME /certs/fruits-ui.crt Verify Certificates \u00b6 $TUTORIAL_HOME /bin/verifyCerts.sh $TUTORIAL_HOME /certs/fruits-ui.crt $FRUITS_UI_IP .nip.io With Verification succeeded! , we are now all set to encrypt our gateway traffic. Create SSL Secret \u00b6 To be able to encrypt the traffic via Gloo Gateway, we need to configure the TLS certicates. The TLS certficate is configured using Kubernetes Secret. Decrypt the private key that we used to create the Certificate Signing Request, step certificate key $TUTORIAL_HOME /certs/fruits-ui-key --out = $TUTORIAL_HOME /certs/fruits-ui.key Note The command out put says its public key, but its actually decrypted private key kubectl create secret generic fruits-ui-tls -n ui \\ --from-file = tls.crt = $TUTORIAL_HOME /certs/fruits-ui.crt \\ --from-file = tls.key = $TUTORIAL_HOME /certs/fruits-ui.key \\ --from-file = ca.crt = $TUTORIAL_HOME /certs/fruits-ui-ca.crt Created Trusted CA Secret \u00b6 Lets also make sure the trusted-ca secret is available in the deployment namespace ui : kubectl get secrets trusted-ca -n ui If you dont find the CA secret, create the same by, envsubst < $TUTORIAL_HOME /cluster/gloo/trusted-ca.yaml | kubectl apply -n ui -f - Scale Deployment UI \u00b6 As we have already deployed the fruits-app-ui , its enough that we scale it, kubectl -n ui scale --replicas = 1 deploy/fruits-app-ui Wait for the UI application to be up and running, kubectl rollout status -n ui deploy/fruits-app-ui --timeout = 60s Access UI \u00b6 export FRUITS_UI_URL = \"https:// ${ FRUITS_UI_IP } .nip.io\" echo $FRUITS_UI_URL Open the $FRUITS_UI_URL on your browser.","title":"Application UI"},{"location":"ui/#ensure-environment","text":"Lets ensure that we have all the required environment variables set for this module, echo \"\\n Tutorial Home: $TUTORIAL_HOME \\n\" echo \"\\n Gloo Gateway Proxy IP: $GLOO_GATEWAY_PROXY_IP \\n\" echo \"\\n Gloo Proxy HTTP URL: $GLOO_PROXY_HTTP_URL \\n\" echo \"\\n Gloo Proxy HTTP URL: $GLOO_PROXY_HTTPS_URL \\n\" echo \"\\n ROOT CA Cert: $ROOT_CA_CERT \\n\"","title":"Ensure environment"},{"location":"ui/#prepare-fruits-ui-deployment","text":"","title":"Prepare Fruits UI Deployment"},{"location":"ui/#create-namespace","text":"kubectl create ns ui","title":"Create Namespace"},{"location":"ui/#fruits-ui-ssl-certificates","text":"To create the Fruits UI SSL certificate, we need to know the Fruits UI service LoadBalancer IP. To get the LB IP let us create the Fruits UI service, kustomize build $TUTORIAL_HOME /apps/microservice/ui/overlays/minikube | envsubst | kubectl apply -f - Get the Fruits UI LoadBalancer IP, export FRUITS_UI_IP = $( kubectl get svc -n ui fruits-app-ui -ojson | jq -r '.status.loadBalancer.ingress[0].ip' ) Note As you would have observed the deployment fruits-app-ui is not up as we have set the replicas to 0 . We will scale the application once we have certificates ready to be used.","title":"Fruits UI SSL Certificates"},{"location":"ui/#create-fruits-ui-csr","text":"Let us create the CSR and keys, step certificate create fruits-ui --csr \\ --san \" ${ FRUITS_UI_IP } .nip.io\" \\ --san \"*- ${ FRUITS_UI_IP } .nip.io\" \\ --san \"*. ${ FRUITS_UI_IP } .nip.io\" \\ --san \" ${ FRUITS_UI_IP } \" \\ --password-file $TUTORIAL_HOME /certs/password-file \\ $TUTORIAL_HOME /certs/fruits-ui.csr $TUTORIAL_HOME /certs/fruits-ui-key If all goes well you should have the fruits-ui.csr and fruits-ui-key files in the $TUTORIAL_HOME/certs folder.","title":"Create Fruits UI CSR"},{"location":"ui/#create-certificate-request","text":"Having created the CSR we are good to create the cert-manager\u2019s CertificateRequest , As first step let us base64 encode the fruits-ui CSR, export FRUITS_UI_CSR = $( cat $TUTORIAL_HOME /certs/fruits-ui.csr | step base64 | tr -d '\\n' ) Create the CertificateRequest , envsubst< $TUTORIAL_HOME /apps/microservice/ui/certificate-request.yaml | kubectl create -f - Check the status of the CertificateRequest , kubectl get certificaterequests.cert-manager.io -n step-certificates-system ${ FRUITS_UI_IP } .nip.io -o json | jq '.status.conditions[]' If all went well you should see an output like, { \"lastTransitionTime\" : \"2021-08-27T16:15:14Z\" , \"message\" : \"Certificate request has been approved by cert-manager.io\" , \"reason\" : \"cert-manager.io\" , \"status\" : \"True\" , \"type\" : \"Approved\" } { \"lastTransitionTime\" : \"2021-08-27T16:15:14Z\" , \"message\" : \"Certificate issued\" , \"reason\" : \"Issued\" , \"status\" : \"True\" , \"type\" : \"Ready\" } Wait for the certificate to be updated in the request, you can check the same via, CA Certificate can be retrieved by, kubectl get certificaterequests.cert-manager.io -n step-certificates-system ${ FRUITS_UI_IP } .nip.io -o json | jq -r '.status.ca' | step base64 -d > $TUTORIAL_HOME /certs/fruits-ui-ca.crt TLS Certificate can be retrieved by, kubectl get certificaterequests.cert-manager.io -n step-certificates-system ${ FRUITS_UI_IP } .nip.io -o json | jq -r '.status.certificate' | step base64 -d > $TUTORIAL_HOME /certs/fruits-ui.crt","title":"Create Certificate Request"},{"location":"ui/#verify-certificates","text":"$TUTORIAL_HOME /bin/verifyCerts.sh $TUTORIAL_HOME /certs/fruits-ui.crt $FRUITS_UI_IP .nip.io With Verification succeeded! , we are now all set to encrypt our gateway traffic.","title":"Verify Certificates"},{"location":"ui/#create-ssl-secret","text":"To be able to encrypt the traffic via Gloo Gateway, we need to configure the TLS certicates. The TLS certficate is configured using Kubernetes Secret. Decrypt the private key that we used to create the Certificate Signing Request, step certificate key $TUTORIAL_HOME /certs/fruits-ui-key --out = $TUTORIAL_HOME /certs/fruits-ui.key Note The command out put says its public key, but its actually decrypted private key kubectl create secret generic fruits-ui-tls -n ui \\ --from-file = tls.crt = $TUTORIAL_HOME /certs/fruits-ui.crt \\ --from-file = tls.key = $TUTORIAL_HOME /certs/fruits-ui.key \\ --from-file = ca.crt = $TUTORIAL_HOME /certs/fruits-ui-ca.crt","title":"Create SSL Secret"},{"location":"ui/#created-trusted-ca-secret","text":"Lets also make sure the trusted-ca secret is available in the deployment namespace ui : kubectl get secrets trusted-ca -n ui If you dont find the CA secret, create the same by, envsubst < $TUTORIAL_HOME /cluster/gloo/trusted-ca.yaml | kubectl apply -n ui -f -","title":"Created Trusted CA Secret"},{"location":"ui/#scale-deployment-ui","text":"As we have already deployed the fruits-app-ui , its enough that we scale it, kubectl -n ui scale --replicas = 1 deploy/fruits-app-ui Wait for the UI application to be up and running, kubectl rollout status -n ui deploy/fruits-app-ui --timeout = 60s","title":"Scale Deployment UI"},{"location":"ui/#access-ui","text":"export FRUITS_UI_URL = \"https:// ${ FRUITS_UI_IP } .nip.io\" echo $FRUITS_UI_URL Open the $FRUITS_UI_URL on your browser.","title":"Access UI"},{"location":"waf/","text":"Gloo Edge::Web Application Firewall \u00b6 At the end of this chapter you would have known how to: Configure WAF A WAF protects web applications by monitoring, filtering and blocking potentially harmful traffic and attacks that can overtake or exploit them. Gloo Edge Enterprise includes the ability to enable the ModSecurity Web Application Firewall for any incoming and outgoing HTTP connections. For this demo, let us assume that our application does not support Firefox yet so for any requests that come with Firefox browser agent need to be blocked and informed. apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : fruits-api namespace : gloo-system spec : displayName : FruitsAPI virtualHost : options : # -------- Web Application Firewall - Check User-Agent ----------- waf : # (1) ruleSets : # (2) - ruleStr : | # (3) SecRuleEngine On SecRule REQUEST_HEADERS:User-Agent \".*Firefox.*\" \"deny,status:403,id:107,phase:1,msg:'unsupported user agent'\" customInterventionMessage : \"Firefox not supported\" # (4) domains : - \"*\" routes : # --------------------- Application Routes ----------------- - matchers : - prefix : /api/ routeAction : single : upstream : name : fruits-app-fruits-api-8080 namespace : gloo-system options : prefixRewrite : /v1/api/ # ---------------- Rate limit config ---------------------- rateLimitConfigs : refs : - name : global-limit namespace : gloo-system Define WAF rules The WAF block can have one or more ruleSets The rule inspects the User-Agent header The message to display for rule voilations Let us update the Virtual Service with WAF enabled, kubectl apply -n gloo-system -f $TUTORIAL_HOME /apps/microservice/fruits-api/gloo/virtual-service-waf.yaml Try simulating the API request as if it was generated from Firefox browser: http $GLOO_PROXY_URL /api/fruits/ User-Agent:Firefox The request should with a response, HTTP/1.1 403 Forbidden content-length: 21 content-type: text/plain date: Wed, 18 Aug 2021 11:24:46 GMT server: envoy Firefox not supported No try the same request with any other user agent which should succeed. http $GLOO_PROXY_URL /api/fruits/ User-Agent:Safari","title":"Web Application Firewall"},{"location":"waf/#gloo-edgeweb-application-firewall","text":"At the end of this chapter you would have known how to: Configure WAF A WAF protects web applications by monitoring, filtering and blocking potentially harmful traffic and attacks that can overtake or exploit them. Gloo Edge Enterprise includes the ability to enable the ModSecurity Web Application Firewall for any incoming and outgoing HTTP connections. For this demo, let us assume that our application does not support Firefox yet so for any requests that come with Firefox browser agent need to be blocked and informed. apiVersion : gateway.solo.io/v1 kind : VirtualService metadata : name : fruits-api namespace : gloo-system spec : displayName : FruitsAPI virtualHost : options : # -------- Web Application Firewall - Check User-Agent ----------- waf : # (1) ruleSets : # (2) - ruleStr : | # (3) SecRuleEngine On SecRule REQUEST_HEADERS:User-Agent \".*Firefox.*\" \"deny,status:403,id:107,phase:1,msg:'unsupported user agent'\" customInterventionMessage : \"Firefox not supported\" # (4) domains : - \"*\" routes : # --------------------- Application Routes ----------------- - matchers : - prefix : /api/ routeAction : single : upstream : name : fruits-app-fruits-api-8080 namespace : gloo-system options : prefixRewrite : /v1/api/ # ---------------- Rate limit config ---------------------- rateLimitConfigs : refs : - name : global-limit namespace : gloo-system Define WAF rules The WAF block can have one or more ruleSets The rule inspects the User-Agent header The message to display for rule voilations Let us update the Virtual Service with WAF enabled, kubectl apply -n gloo-system -f $TUTORIAL_HOME /apps/microservice/fruits-api/gloo/virtual-service-waf.yaml Try simulating the API request as if it was generated from Firefox browser: http $GLOO_PROXY_URL /api/fruits/ User-Agent:Firefox The request should with a response, HTTP/1.1 403 Forbidden content-length: 21 content-type: text/plain date: Wed, 18 Aug 2021 11:24:46 GMT server: envoy Firefox not supported No try the same request with any other user agent which should succeed. http $GLOO_PROXY_URL /api/fruits/ User-Agent:Safari","title":"Gloo Edge::Web Application Firewall"}]}